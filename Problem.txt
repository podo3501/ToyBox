CreateWICTextureFromFile안에 GetWIC함수가 InitOnceExecuteOnce로 Factory를 생성하는데 싱글톤 패턴
을 쓰기 때문에 Test가 독립적으로 작동하지 못한다. 예를들면 1번 테스트에서 static 변수에 2를 넣고 2번
테스트에서 그 값을 읽으면 초기화가 안 되어서 기대한 값이 아니라 2라는 값이 나오는 것처럼 static 변수
를 초기화 해야 하는 일이 생겼다. 그래서 WICTextureLoader.h와 cpp를 수정해서 static 변수를 초기화 하는
WICOnceInitialize함수를 추가했다.
로딩할때 한번 로딩 하고 나면 싱글톤 함수가 같은 값을 반환하기 때문에 다른 파일을 읽을려고 하면 에러가
나는 현상이 발생했다. 그래서 로딩할때 WICOnceInitialize함수를 한번 더 호출해 주어서 새롭게 초기화 된
Factory를 사용하게끔 한다.

google test(gmock)에서 pch를 사용하는 방법.
NuGet에서 gmock 패키지를 받아서 설치 했을때 .cc파일이 프로젝트에 합류됨으로써 컴파일을 하면 .pch
파일을 include 하라고 나오는데 google test가 ms 전용이 아니기 때문에 pch(pre compile header)를 적
용시킬수는 없기 때문이다. cmake를 사용하면 gmock과 gtest프로젝트등 여러개가 만들어지는데 이렇게
하면 아마 pch를 사용할 수 있을 것이다. 내가 한 방법은 깃허브에서 코드를 다운 받은후 빈 프로젝트를 
만들어서 .cc 파일 (gmock-all, gtest-all 두개만 컴파일 하면 된다. 왜냐면 다른 .cc파일을 all 파일이 다 인
클루드 하기 때문이다)을 추가한후, 빌드한다. 이 프로젝트는 GoogleTestLib로 만들었으며, 컴파일 하고
나면 lib가 만들어진다. 그리고 만들어진 프로젝트(lib)를 Test 프로젝트(ToyTest)에서 참조했다. Test 프로
젝트는 만들때 google test 프로젝트로 만든후 NuGet에서 설치돼 있는 gtest를 삭제한다. 왜냐면 google 
mock이 포함되어 있지 않아서이다. 그리고 main을 작성해 준다.
--------------요약--------------
1. 빈 프로젝트 GoogletTestLib 만들기
2. google test GitHub에서 다운받아서 cc파일 두개 추가
3. include 폴더 디렉토리 설정하기
4. 컴파일 되는지 확인
5. 새프로젝트 만들기 해서 google test 프로젝트로 프로젝트 만들기
6. NuGet에서 설치되어 있는 기본 gtest를 삭제
6. GoogletTestLib을 참조로 연결
7. main함수 작성

message에서 PostQuitMessage 메세지가 남아있어서 다음 테스트에 영향을 미치는듯 하다.
Destroy함수가 불리면 WM_DESTROY를 부르고 거기서 WM_QUIT메세지가 큐에 담긴다. 이 메세지는 다
음 테스트에 작동되면서 테스트 종료를 일으킨다. 끝낼때에는 Message Queue의 내용을 지워서 테스트
가 독립적이게 만들어야 한다. 

Microsoft::WRL::Wrappers::RoInitializeWrapper initialize(RO_INIT_MULTITHREADED);
이 함수를 리팩토링으로 다른 함수로 옮겼더니 멀티쓰레드 적용이 되지 않았다.  RAII를 사용하기 때문에
함수가 끝나면 사라진다. 사라지기 전에 com을 생성해야 하기 때문이다.

한 클래스에 unique_ptr 변수가 2개 있으면 선언 순서의 역순으로 소멸자가 호출된다.

1>D:\ProgrammingStudy\ToyBox\Toy\Button3.cpp(36,43): warning C4100: 'iter': 참조되지 않은 정식 매개 변수입니다.
1>(소스 파일 '/Button3.cpp'을(를) 컴파일하는 중)
1>    D:\ProgrammingStudy\ToyBox\Toy\Button3.cpp(36,43):
1>    템플릿 인스턴스화 컨텍스트(가장 오래된 인스턴스화 컨텍스트)가
1>        D:\ProgrammingStudy\ToyBox\Toy\Button3.cpp(36,15):
1>        클래스 템플릿 멤버 함수 'std::ranges::in_fun_result<conditional<std::ranges::borrowed_range<_Rng>,unknown-type,std::ranges::dangling>::type,_Fn> std::ranges::_For_each_fn::operator ()(_Rng &&,_Fn,_Pj) const'을(를) 컴파일하는 중입니다.
1>        C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm(488,13):
1>        'indirectly_unary_invocable<`Button3::LoadResources'::`2'::<lambda_1>,std::_Projected_impl<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum Button3::ButtonState const ,ButtonImage> > > >,std::identity>::_Type>' 개념을 평가하는 동안
1>        C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(964,60):
1>        'invocable<`Button3::LoadResources'::`2'::<lambda_1> &,std::pair<enum Button3::ButtonState const ,ButtonImage> &>' 개념을 평가하는 동안
1>        C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\concepts(262,10):
1>        컴파일되는 함수 템플릿 인스턴스화 'unknown-type std::invoke(_Callable &&,_Ty1 &&,_Types2 ...) noexcept(<expr>)'에 대한 참조를 확인하세요.
1>        C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits(1711,45):
1>        클래스 템플릿 멤버 함수 'unknown-type std::_Invoker_functor::_Call(_Callable &&,_Types ...) noexcept(<expr>)'을(를) 컴파일하는 중입니다.
1>        C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits(1610,46):
1>        컴파일되는 함수 템플릿 인스턴스화 'void Button3::LoadResources::<lambda_1>::operator ()<std::pair<const Button3::ButtonState,ButtonImage>>(_T2 &) const'에 대한 참조를 확인하세요.
1>        with
1>        [
1>            _T2=std::pair<const Button3::ButtonState,ButtonImage>
1>        ]
빌드창에 이렇게 떳길래 보니까 '오류'가 아니라 '경고'였다. w4에서 w3로 경고 수준을 낮추면 사라진다.
map에 const auto& 변수로 iterator를 사용하는데 그 iterator 변수를 사용하지 않아서 나오는 경고치고는 너무 살벌하다.

렌더링 할 객체들의 데이터를 확인하려면 렌더러를 인자로 넣어야 한다.
그런데 렌더러를 인자로 넣지 못하는 경우가 생긴다. barrier같은것이 있을경우 콜백으로 받아서 처리해야 하기
때문이다. 그래서 콜백 함수와 랜더러를 인자로 하는 함수 2개를 만들어서 테스트 할 수 있게끔 한다.

unique_ptr은 pImpl을 쓰고 싶게(전방선언을 하고싶게) 만드는데 여기서 문제점은
unique_ptr은 raw포인터와 같아서 delete방식을 알고 있어야 한다. 즉 소멸자가 정의되지 않으면
오류 C2027 정의되지 않은 형식 '클래스명'을(를) 사용했습니다. 라고 나온다.
그러면 소멸자를 cpp에서 정의해 주면 되긴한데 문제는 생성자가 template인 경우는 이게 또 말썽이다
그래서 template 생성자를 cpp에 명시적으로 선언해 주거나 아니면 중요한 게 아닐 경우는 생성자에 
template를 안 쓰는게 좋은 것 같다.  그리고 에러 메세지가 꼭 저렇게 안나오고 애매하게 나오는 경우도
있으니 주의를 요함
생성자 소멸자 둘다 cpp에 정의한다. h에 = default 해도 소용없음 
*변수를 h에 선언할때 초기화 할수 있는데 초기화를 하면 cpp에 정의해도 필요없게 됨. 선언과 동시에 초기화를
하지 않아야 함.ex) std::unique_ptr<Material> m_materials{ nullptr }; <-- m_materials{ nullptr } 중괄호 없애야함.
그 클래스를 부르는 상위 클래스에도 생성자, 소멸자를 cpp에서 = default 같은 걸로 정의해 주어야 한다.

Google Test에서 SEH 예외가 발생한다는 것은 테스트 실행 중에 시스템 오류(예: 잘못된 메모리 접근, NULL 포인
터 참조 등)가 발생했음을 의미함. 코드중에 어떤 포인터가 잘못됐는지를 잘 찾아보자. 예를들면 unique_ptr로
만들고 나서 scope가 지나서 자동으로 사라진지 모르고 거기다가 셋팅한다던지 등등.

ttf폰트에서 spritefont로 바꿀때 한글 및 기호, 영어를 넣어서 뽑는 옵션
MakeSpriteFont "맑은 고딕" MaleunGothicS16.spritefont /FontSize:16 /CharacterRegion:0xAC00-0xD7A3 /CharacterRegion:0x0020-0x007E
 /FastPack
 /CharacterRegion:0xAC00-0xD7A3 한글 추가 옵션
 /CharacterRegion:0x0020-0x007E 영어 및 기호 옵션
 그냥 옵션 없이 실행하면 한글 폰트임에도 영어와 기호 옵션만 나온다.
 /FastPack을 안하면 실행이 끝날때까지 4시간 정도 걸린다.

 한글 spritefont 만들어서 한글 출력하기
한글 입력 하는 방법 찾고 있었음. 깃헙에서 검색해서 괜찮은거 붙일예정
https://github.com/search?q=hangul+ime&type=repositories
MakeSpriteFont "굴림 보통" hangle.spritefont /FontSize:32 /CharacterRegion:0xAC00-0xD7A3
MakeSpriteFont.exe MyFont.ttf MyFont.spritefont /CharacterRegion:0xAC00-0xD7A3 /CharacterRegion:0x0020-0x007E
MakeSpriteFont "맑은 고딕" MaleunGothicS16.spritefont /FontSize:16 /CharacterRegion:0xAC00-0xD7A3 /CharacterRegion:0x0020-0x007E
 /FastPack

 DirectXTK12와 imgui를 붙일때 주의점은 example에서 보면 ImGui_ImplDX12_Init 이 함수를 호출할때 
 DXGI_FORMAT_R8G8B8A8_UNORM 으로 호출하는데 기본 DirectXTK12설정은 DXGI_FORMAT_B8G8R8A8_UNORM
 로 되어 있다. 설정을 자신의 백버퍼에 맞게 맞추어 줘야 한다. 버퍼가 2개인데 3개로 설정해도 돌아가긴 한다.

 imgui를 랜더링 할 때에는 제일 마지막에 렌더링을 해 주어 다른 것들이 충돌이 나지 않게 한다.
 PreRender()
 일반적 렌더링
 ...
 imgui 렌더링	<- 제일 마지막
 Present()

 imgui의 window에 클라이언트 화면을 띄우기 위해서는 Render Texture View를 써서 텍스춰를 생성한 후 그 텍스
 춰의 아이디 값을 imgui에 넘겨주어야 하는데 이때 텍스춰의 이미지가 힙에 저장되어 있는데 imgui의 힙과 다른
 텍스춰의 DescriptorHeap이 다를 경우 찾지 못해서 이미지가 안 띄워진다. 그래서 이미지를 찾아서 띄우기 위해서
 는 같은 힙상에서 처리를 해야할 필요가 있다. 
 window에 클라이언트 화면을 띄우는 이유는 클라이언트 화면 뿐만 아니라 이미지 편집, 캐릭터 움직임, UI 편집,
 등등을 할 수 있게 하기 위함이다. 화면이 하나 밖에 없다면 UI툴, 캐릭터 툴, 이미지 툴 등등 여러가지 툴이 나오기
 때문에 더 번거로울 수 있다.

 TMP할때 함수가 정의 되어 있지 않다고 한다면, 그 부분을 다른 함수로 만들어서 cpp로 넘기면 가능해진다.

 Json에서 get<T>()를 사용해서 변환할때 from_json 함수가 있어야 하고, '기본 생성자'가 정의 돼 있어야 한다.

 CoInitializeEx(nullptr, COINITBASE_MULTITHREADED); 이 함수를 사용하면 반드시 CoUninitialize(); 를 호출 해야
 하는데 RAII를 적용한 버전이 Microsoft::WRL::Wrappers::RoInitializeWrapper initialize(RO_INIT_MULTITHREADED);
 이다. 이건 나중에 해제코드를 할 필요가 없다. #include <wrl/wrappers/corewrappers.h> 헤더를 include 해 준다.
 
 예외 발생(0x00007FFE59CDFB4C, Tool.exe): Microsoft C++ 예외: wil::ResultException, 메모리 위치 0x000000C381D3AB50.
예외 발생(0x00007FFE59CDFB4C, Tool.exe): Microsoft C++ 예외: [rethrow], 메모리 위치 0x0000000000000000.
CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE); 
CoUninitialize(); 
이렇게 쌍으로 호출했음에도 무언가 이상동작을 한다. 예외발생이라고 나오며, 한번만 초기화 해주는게 맞지만,
깔끔하게 처리한다면 RAII로 하는게 나을것 같다.

1>C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\commdlg.h(674,20): error C3646: 'lpLogFont': 알 수 없는 재정의 지정자입니다.
파일 열기 다이얼로그를 띄웠을때 충돌되는 메세지이다. 이것을 해결하려면 include 순서를 바꿔야 하는데 
DirectXTK와 선언순서가 충돌되는 듯 하다.

ImGui 창에서 버튼이나 이런 widget을 붙이면 widget만큼 y값이 내려가 보인다. 실제로 좌표상은 동일하며 화면
에 표시할때 버튼 부분의 높이 값만큼 밑으로 내려서 랜더링 하는 듯 하다.

clone을 만들때 복사 생성자를 사용하게 되는데 public으로 만들었을 경우 vector 같은 컨테이너가 이 복사 생성
자를 써서 복사하면서 값을 넣는 경우가 있으므로 오작동의 원인이 된다. 애초에 clone을 만들 때에는 복사가 임
의로 생성하지 않게끔 명시적으로 만들려는 의도인데 복사 생성자가 은근슬쩍 해 버리면 문제가 생기게 된다. 
이번에는 emplace_back 할때 복사 생성자가 호출되어 값이 슬라이스 되는 문제가 발생했다. 이런 문제는 디버깅
하기 어려운 문제로 연결 될 수 있기 때문에 복사 생성자를 protected로 만들고 호출 할때에는 make_unique로
만들지 않고 unique_ptr<xxx>(new xxx(*this)); 로 해서 내부에서 protected로 만들었음에도 호출 하게끔 하게 한
다. 복사 생성자는 protected이므로 컨테이너에서는 복사 하지 못한다고 오류가 나올 것이다. 그때 clone으로 대
체하자.

C2665 make_unique에서 생성 못했을때의 에러코드가 너무 길어서 어디 줄인지 모를때가 많다.
다음의 문장이 보이면 그 밑에 해당 코드줄이 있다.
예시)
템플릿 인스턴스화 컨텍스트(가장 오래된 인스턴스화 컨텍스트)가
D:\ProgrammingStudy\ToyBox\Toy\GameMainLoop.cpp(39,19):
컴파일되는 함수 템플릿 인스턴스화 'std::unique_ptr<Panel,std::default_delete<Panel>> 
std::make_unique<Panel,const char(&)[5],DirectX::SimpleMath::Rectangle,0>
(const char (&)[5],DirectX::SimpleMath::Rectangle &&)'에 대한 참조를 확인하세요.

msvc는 특별한 설정을 하지 않으면 /std:c++가 설정돼있든 말든 __cplusplus 값이 199711L로 predefine 돼 있음.
XMINT2를 == 할려고 하는데 안되어서 자세히 보니 __cplusplus 값이 1997년 11월 짜리로 돼 있음. c++20으로 
바꾸어도 바뀌지 않음. __cplusplus의 값을 바꾸려면 컴파일러 옵션에 /Zc:__cplusplus를 추가하고
/std:c++ 설정(14든 17이든 20이든)을 해 줘야 함. 

이 문제의 발단은 UITransform안에 UIComponent를 넣었던 것이 문제다. vector가 
UITransform에 걸리면 loop를 돌릴때 깔끔하게 안 돌아간다. Component용, Transform용 
loop를 2개 만들면 되는 차원을 넘어서서 재귀코드 자체가 성립하지 않게 된다. 왜냐하면 Transform에서는
Component를 알수 있지만 반대는 되지 않는다. 따라서 재귀함수 호출이 Transform으로 해야 하는데 
그러면 Component에서 해야 할 일이 잘 안될 수도 있고, Transform 클래스와 Component 클래스는 
서로가 friend 로 엮여야 하기 때문이다. 이것은 리팩토링이 되지 않는 클래스가 될 것이다.
Composite패턴은 결국 Iterator패턴을 쓸수 밖에 없다. 그렇지 않으면 리팩토링이 되지 않는다.

컴포지트 패턴은 클래스가 단일 책임과 다중책임이라는 2가지의 책임을 동시에 가지고 있는 부분이라 
속성 하나를 만들면 Component에서 속성을 가져오는 함수와 Component 집단에서 가지고오는 함수가 필연적
으로 2개가 생기게 된다. 그래서 속성이 몇개 안 생기더라도 함수는 엄청 많이 생기고 서로서로가 꼬여서 알수
없게 되는게 문제였다. 즉. 단일책임과 다중책임을 분리시키는게 문제인데, 이것을 분리시키는 방법으로는 
딱히 불리는 패턴은 없는데 확장 클래스를 만들어서 Component를 생성자 인자로 넣고 확장 클래스를 friend
로 만들어 이쪽에서 다중적인 일을 처리하는 클래스를 만들면 될 것 같다. 기존의 Component는 단일책임만
맡게 만들어서 둘을 분리하면 어떨까.