테스트 코드 쪽에 개선사항이나 나중에 고쳐야 할 사항을 적어놓는 것도 좋은 방법일 것 같다.

EXPECT_TRUE 같은 검증용 예약어 같은 경우는 그 파일내에서만 사용하고 fixture나 다른 함수에서 사용하는건
나중에 가독성의 문제가 생길 가능성이 있다. 한군데로 모으면 코드량이 줄긴 한데 보기가 어렵고 따라가야 
하는데 테스트의 특성상 테스트 코드를 함수따라 분석하고 있으면 쉽게 피로해지기 때문이다.

테스트와 실제 코드파일을 1:1로 매칭 했을때의 이점은, 테스트 코드는 명확성을 위해서 길게 만드는 것이 허용
된다는 것이다. 1:1로 매칭 하지 않고 fixture를 한군데 몰아 넣고 임의의 cpp로 다량의 테스트를 진행하는 경우
테스트가 긴것이 싫어지기 때문에 시나리오 테스트를 대부분 하게 되는데, 이때 코드의 가독성이 현저히 떨어지
게 된다. 특히나 테스트 코드의 경우 하드 코딩된 것들이 많은데 하드 코딩된 코드를 몇십줄 계속 보면 짜증이 올
라오기 때문이다. 테스트 코드는 짧게 딱 필요한 만큼만 보여주고 바로바로 인식 가능한 수준이어야 만들때도
부담없고 볼때도 부담없다. 테스트 코드는 보기 위해서 존재하는 것이기 때문에 책임이 간결하면서 명확하게,
추적이 쉽게, 실패가 되었을때 바로 가능해야 한다. 테스트 코드를 들여다 보는 시점은 작성하고나서 몇주, 몇달
뒤가 될텐데, 이때 실제 코드를 보는 것도 짜증나는데 테스트 코드를 분석해야 한다는 그 부담감이 tdd를 멀어지
게 하는 것이다. 그래서 시나리오 테스트는 꼭 필요한 것만, 최대한 짧은 흐름으로 해야 한다.

테스트 코드내 cpp에서는 주석을 적극적으로 사용하자. 여기는 테스트 하는 코드이기도 하지만, 기술문서의
성격도 같이 가지고 있기 때문에, 주석을 기피할 필요가 없다.

테스트 코드 내에 헬퍼 함수가 길어지면 이 코드를 분석하게 된다. 그러면 tdd의 본질에 반하는 것이기 때문에
tdd 코드는 은닉이 되는 함수를 만들지 말고, 표현되는 함수를 만들어야 한다. 예를들어, 
SimulateClick(button); 
이것은 클릭을 하는 것, 3번의 행동이 들어가 있지만 함수의 이름을 보고 3번의 행동이 있을 것임을 예측가능하다.
AttachTwoComponents(root, childA, childB);
이것은 두개의 컴포넌트가 어떻게 붙었는지, 또 위치가 어떻게 되는지, 어떤 정렬인지 등등을 알아야 한다면
이 함수를 열어보아야 한다. tdd 코드는 읽는 행위에 중점을 두고 있기 때문에 이렇게 함수를 '열어'보아야 한다
면 이 tdd 헬퍼함수는 잘못 만들어진 함수다.
레거시 코드에서는 은닉과 표현 둘다를 써서 코딩하지만, tdd 코드에서는 표현 코딩만 사용하자.
(표현코딩의 간단한 예시라면 한두줄짜리 인라인 같은 거라고 봐도 무방하다.)

코딩중에 버그가 생겨서 버그를 재현하기 위한 테스트코드를 만들수 있다. 이건 논리적인 테스트가 아니라 단지
버그를 잡기 위한 테스트 코드인데, 잡고 나면 테스트 코드를 삭제하면 된다. 혹시 이 테스트 코드가 논리적으로
검증이 안된 부분이었다면 남겨놓고, 검증코드가 있는데 여기만 발생하는 것이면, 이 부분을 수정하면 다시는 
이런일이 없기 때문이다. 

component에서 마우스 드래그 했을때 테스트가 안되는 현상을 발견했고, 그 이유를 찾아보니 마우스 드래그 
했을때 그 변화값을 컴포넌트 안에서 마우스를 가져와서 계산하고 있었다. 마우스의 움직임을 감지하는 것은
UIModule의 책임인데 component가 아직 그것의 일정 부분을 사용하고 있었기 때문이다. 그러니까 단일 책임
원칙이 지켜지지 않아 테스트가 안되는 현상이었던 것이다. 물론 전역에서 마우스 이동을 셋팅하고 테스트를
해 줄수도 있지만, 테스트는 그 클래스에서 시작과 완결을 기본으로 하기 때문에 그것이 이상했고, 그 이상함은
마우스의 처리가 단일원칙 위반에서 비롯된 것임을 알게되었다. 이렇듯 tdd는 oop를 강제한다.

tdd를 사용하면 내부에 assert로 해서 하지 말아야 할 것을 지정할수도 있지만, 이건 구현의 문제라서 의도를 
나타내는것은 어렵다. 즉, 코드가 변해가면 결국 처음의 assert를 한 의도가 점점 알수 어렵게 되고, 결국 assert
자체가 생각하게 만들게 된다. 하지만 tdd로 밖에서 테스트를 한 경우에는 구현의 중점을 둔게 아니라 의도에
중점을 둔 것이기 때문에 코드가 변해감에 따라서 자연스럽게 변하게 되고 의도를 나타내고 있기 때문에 달라
질 가능성이 적어진다. 그리고 레거시 코드가 주석으로 변해가서 지저분해지는 것을 막을 수 있고, 개별적으로
테스트를 하기 때문에 굳이 내부에 주석을 쓸 필요도 없어지게 된다. 대신 외부에 쓸공간이 tdd로 마련돼 있기
때문에 여기에서는 충분히 그 의도와 주석을 꼼꼼히 달아 놓으면 다음에 볼때에 큰 무리 없이 볼수 있게 된다.

tdd는 일기장 같은 느낌이다. 개발하면서 이것을 개발했을때의 생각과 느낌을 적어 놓을수 있는 공간이자,
그것을 테스트를 통해서 단지 글만이 아니라 그것을 실제로 테스트도 하기 때문에 살아있는 주석이 되는 것이다.
tdd코드 뿐만 아니라 주석도 각 tdd 하는 곳에 꼼꼼히 달아놓는 습관을 기르면 추후에 분석할때 큰 도움이 된다.

Region 관련 테스트를 하는데 UIModule이 Region을 관리하는데 UIModule은 Panel을 기본으로 가지는 구조이다.
그런데 이 구조 때문에 Panel을 자식으로 붙여서 Region 테스트를 하는게 가장 편한데, 반대로 이야기 한다면,
Panel에 의존하는 코드가 문제이다. 그렇다면 테스트도 그렇게 짤수 밖에 없는데, 그 말은 UIModule을 Locator로
분리해야 하지 않느냐 라는 문제에 당도하게 된다. Locator가 나을까 아니면 Adapter가 나을까 생각하다가 Adapter
로 했는데, Locator의 단점보다 Adapter의 단점이 더 크게 느껴지는것이 테스트를 통해서 확인할 수 있었다. 즉,
tdd를 하면서 테스트가 어딘가에 의존한다는 것은 프로그램을 다시 한번 돌아보는 계기를 마련해 주는 것이다.

tdd쪽 코드 정리나 클라이언트 코드 정리를 하고 있으면 때때로 무의미한 것이 아닌가 생각될때가 있는데,
추후에 크게 리팩토링 할때가 와서 리팩토링하면서 설계를 다시 짜서 맞추는 것이 가능한 것과, 그걸 하는데
걸리는 시간을 보면 깜짝 놀란다. 생각보다 엄청 빨리 되기 때문인데, 결국 코드 부채를 쌓지 않고 코딩 하면
나중에 안되는 부분이 되거나, 시간 감소효과를 톡톡히 볼수 있기 때문에, 코드 정리 및 리팩토링을 하는 것이
시간 낭비라고 생각된다면, 그것은 작은 프로젝트 일 경우에는 시간 낭비가 될 수 있지만, 적어도 3-4천줄만
넘어가더라도 tdd의 진가가 발휘되기 때문에 그정도로 작은 프로젝트의 경우에는 상관 없지만, 그렇지 않다면
리팩토링이나 코드 정리하는데 시간이 아깝다고 생각하지 말고, 코드 정리하는 시간을 어떻게 하면 빨리 할수
있을지를 강구해야 한다.