UI좌표는 해상도의 변화에 따라서 UI의 위치가 변하게 되는데 그 부분을 방지하기 위해 0-1 까지로 한 다음
현재 해상도에 곱하면 실제 위치 값이 나오게 된다. (800x600, 0.5 0.5라면 400, 300) UI의 시작좌표는 일반적
인 좌상단이 아니라 중점으로 한다.

다이얼로그를 만들던 중 마우스에서 클릭하면 3개의 다른 지점에서 반응 하는게 아니라 버튼 클래스에서
전체적으로 반응하는데 추후에 이 클래스를 가져다가 쓰는 곳에서 이 부분을 또 만들어야 하는 단점이 있기에
리팩토링해서 그 부분을 만든다. 이미지1개짜리 버튼을 만들려면 새로 만들거나 이미지를 3개로 쪼개서 써야 
하기 때문에 각각의 하나 짜리를 만든후 3개로 묶도록 리팩토링 한다.

서비스 로케이터 패턴을 쓸려고 했는데 일단 전역적인 것은 나중에 더 필요하게 되면 고려하기로 했다.

UI에서 Component의 위치는 Component를 가지는 클래스가 정하고 그 위치에 어디가 중심인지는 Component
자신이 알고 있다. Component의 크기는 Component가 가지고 있어서 Picking같은 것을 호출할때에는 Component
에서 처리하도록 한다.

friend함수인 to_json 을 쓸 것인가 아니면 Process 같은 중간 클래스를 만들어서 read, write를 한데 묶어서 할까
했는데 to_json을 쓰면 장점은 복사 생성자나 = 이런 것들을 쓸 수 있게 되어서 가독성이 좋고, 중간 클래스를 
만들면 read, write 한군데에서 처리하니 friend 함수도 사라지고 코드가 깔끔해지는 장점이 있다. 일반적인 가독
성이면 to_json이 좋고, 프로그램적 가독성은 Process로 처리하는게 좋을 것 같다. 이번에는 to_json으로 해서 
복사생성자 같은 것들을 좀 더 사용하도록 해 보겠다. 속도는 to_json이 더 빠를지 느릴지 잘 모르겠지만, 일반적으로
만들어 준것이 만든것보다 좋을 것 같다. 
json에서 get<T>()를 사용하면 읽을때 타입별로 객체를 생성하고 초기화 하는데, 이걸 안쓰면 직접 이 부분을 
만들어야 한다. 예를 들면 "Type": "Button" 이렇게 저장하고 읽을때 버튼 클래스를 읽어야 하는 부분을 구현해야
하는데 만들기 쉽고 어렵고의 문제라기 보다는 코드가 많아지면 결국 관리할때 문제가 생기기 때문이다.
get<T>()를 사용한다고 해도 tag 로처리할지 RTTI로 할지 고민하다 tag로 처리하였다. Process를 사용한다고 해도
복사 생성자 이동생성자는 있어야 하고, 바꾸면 to_json 부분이 process 로 바뀌는 것 말고는 크게 달라질것 같지
않다. 결국 Process클래스는 to_json from_json을 if문 하나로 이쪽저쪽 갈라주는 용도일 뿐이니까.
그렇개 생각해서 Process 클래스를 만들려고 보니 클래스 안에 클래스 처럼 중첩구조를 가진 데이터에서 Process()
함수를 불러줄때 json에 키값을 셋팅하고 넘겨주어야 한다. 결국 to_json을 하나로 합치는 것 이외에 어떤 이점이
찾을 수 없게 된다. friend가 걸리적 거리고 함수가 두개 쌍이 있어야 하지만 그것을 제외하기 위해서 

UI에서 SRT할 일이 별로 없기 때문에 Transform 하는 클래스의 존재가 좀 그렇긴 하지만, 이 클래스를 만드는
이유는 SRT를 생각해서 순서를 정해주어서 곱해야 하기 때문에 매우 귀찮기 때문에 설정한 후에 update 할때
순서에 맞게 처리해 주면 된다. 계속 처리하기 싫을 경우에는 Dirty를 사용해서 바뀌었을때만 하면 되니까. 이 
클래스의 존재 이유는 순서가 헷갈리지 않기 하게 위해서이다. 
AddComponent에서 좌표값은 Translate 이고 ChangeArea는 Scale인데 이 두개가 바뀌어서 호출 되면 이상해
지니까 그것을 한군데로 하기 위함이긴 한데, 실제 이 클래스가 나중에 만들어질지는 모르겠다.
//TransformComponent* transComp = panel->GetTransformComponent("Button");
//transComp->ChangeArea({ 0, 0, 126,48 });

XMVECTOR는 SIMD(빠른 처리)를 위해서 사용. GPU로 값을 옮길때에는 XMFLOAT(단순구조체타입)으로 변환
해서 옮긴다. 즉 cpu에서 처리할때는 빨리 처리해야 하기 때문에. 2D의 경우에는 XMUINT2가 있는데 이건 SIMD
와는 관계가 없다. 그렇기 때문에 2D용 단순 구조체 타입도 없다. 그럼에도 불구하고 이름을 비슷하게 지은 이유는
아마도 XMVECTOR와 XMUINT2가 변환 되는 것을 지원하기 때문인 것 같다. SIMD를 사용하고 싶으면 XMUINT2
를 XMVECTOR로 바꾼후 연산하고 그다음에 되돌리면 된다.

UI 이름을 unique하게 만들지 말지 고민하다가 유니크 하게 만들었을 경우 닫힘 버튼 같은 경우에는 유니크 하지
않은 이름 때문에 코드가 이상하게 될 것 같다. 그래서 일단은 유니크하게 만들고 추후에 시간이 지난후 실제로
데이터를 만들면서 생각해 보기로 하자. 지금 생각해서 만들면 나중에 가서 또 다시 만들어야 할 것 같다.

리스트는 이러한 형식을 담는 것이다라는 것이고, 넣을 컨테이너를 요청하고 리스트에서 받아서 데이터를 셋팅
하는 방식으로. 첫번째 attach한 컴포넌트의 형식으로 만들어서 리턴. 세이브할때에는 형식을 세이브. 리스트 컴
포넌트는 리스트와 사이드바로 이루어져 있고 사이드 바는 컴포넌트이지만 혼자서는 만들어지지 않는 특별 컴
포넌트. 리스트와 사이드 바는 callback으로 리스트컴포넌트에 정보를 보내고 중간에서 리스트 컴포넌트는 서로
의 정보를 전달함. 리스트 안에 데이터를 넣을때에는 id로 찾아서 넣는다. 그런데 여기서 문제는 id가 unique하면
코딩할때 id문제로 힘들 것 같다. unique한게 어느 기점부터 unique 하게 바꿔야 하지 않을까?'

스크롤을 내릴때 분명 내려가야 하는데 마우스가 잘못됐거나 하는 이유로 스크롤이 안된 경우에는 내려갈 것을
기대한 눈과 뇌가 조금 '엇'하는 느낌이 온다. 그렇기 때문에 마우스 스크롤로 내릴때에는 다 내려갔음에도 불구
하고 약간 내려갔다가 올라오는 효과가 있어야 눈과 뇌가 편하다.

싱글톤(전역클래스)이 나쁘다고 불려지는건 데이터가 '가변적'인 경우, 여러군데서 데이터를 수정하면 누가 수정
했는지 알기 어렵고, 여기저기서 h를 인클루드 하기 때문에 리팩토링이 안된다는 것인데, 이 두 부분을 적절히
조절하는가가 싱글톤을 잘 쓸수 있는 비결이라고 생각한다. 싱글톤은 안 쓸수는 없다. 안쓰면 너무 많은 함수에
인자로 들어가거나(키보드 클래스), 로그 찍어야 하는데 함수인자로 로그 인자가 들어가면 인상이 찌푸려 질수
밖에 없다. 사운드도 너무 다양하게 여기저기서 쓰이기 때문에 싱글톤이나 그런 비슷한 종류를 안 쓸래야 안 쓸
수가 없다. 따라서 싱글톤을 사용할때에는 데이터가 가변적인가, 최소한의 include로 지역적으로 감출 수 있는가
가 잘 쓰는 방법일 것이다.

컨테이너 컴포넌트의 역할은 마우스가 올라가면 선택된 색깔로 변하고 클릭하면 callback을 날려주고 선택된 
이미지로 바뀌는 역할 평소 제일 연한, 조금 진한, 진한 으로 바뀜. 밑에 배경 색깔이 달라지는 것임. 컨테이너는 
콤보박스, 리스트 등에 쓰임

view는 조회전용으로 쓸때가 베스트임. 무언가를 넣기 위해서 먼저 검사하는 부분에 view를 넣게 되면 다른 코드
에서 insert를 하고 나서 값이 바뀌었음에도 view는 이전 값으로 검사할 수 있음.
template <typename Container>
Texture* findTexture(const Container& textureList, const wstring& filename)
{
    //filename이 갱신되기 전까지는 view는 갱신되지 않기 때문에 nullptr 제외하는 이 코드는 매번 돌지 않는다.
    auto validTextures = textureList | std::ranges::views::filter([](const auto& tex) {
        return tex != nullptr; // nullptr 제외
        });

    auto find  = ranges::find_if(validTextures, [&filename](const auto& tex) {
        return tex->GetFilename() == filename;
        });

    if (find != validTextures.end())
        return (*find).get();

    return nullptr;
}
이 코드에서 filename이 동일한데 textureList가 바뀌었다면, textureList가 바뀐것을 갱신하지 않고 view 처리를 진
행함. 왜냐하면 filename이 동일하기 때문에 view를 갱신할 이유가 없다고 판단하기 때문. 즉, insert 하기 전에 
동일하게 이 로직을 통과한다면 결과가 올바르겠지만, 다른 함수에서 textureList를 넣고 나서 여기서 같은 이름으로
처리하게 된다면 view는 이전 view의 값을 사용하기 때문에 다른 결과가 나온다. 그래서 읽을때  사용하는게
베스트. 그렇지 않다면 사용자가 잘 생각해야 한다. 그리고 view에서 오류가 나면 찾기가 힘들 것 같다.

버튼 컴포넌트 같은 경우에 밖에서 컨테이너 컴포넌트를 넣어주어야 하는데 버튼 컴포넌트는 컨테이너 컴포넌
트가 없으면 버튼의 역할을 하지 못한다. 그 말은 밖에서 컴포넌트를 넣어주는게 아니라 밖에서 인자를 넣어서 
내부적으로 컨테이너 컴포넌트를 생성하는 방법이 맞지 않는가 하는 것인데 코드적으로는 인자를 넣고 내부적
으로 컴포넌트를 생성한다면 인자가 들어갔다가 같은 인자가 다시 컴포넌트에 건네주게 된다. 즉 함수에 많은
인자가 생기는게 불가피해 질 것이다. 그리고 그것들은 단지 다리역할만 할 가능성도 많아진다. 그렇다고 해서
클래스에 컴포넌트에 넣는 식으로만 코딩한다면 책임을 지지 않는다는 인상이 강하게 남는다. 그래서 helper
함수를 만들어서 하는 방식으로 해야 한다. 지금은 헬퍼 함수가 2개가 있는데 그중에 Create 함수가 별일 없이
넘겨주는 역할만 하는 것 같다. 그래서 이 Create 함수와 컨테이너 만드는 함수를 합쳐야 할 것 같다.

렌더 텍스쳐 해서 부분만 보여주는 것은 렌더 텍스쳐 할때 scissor로 잘라내고, trans matrix로 이동해서 부분만
텍스쳐에 그리는 방식을 취하는게 가장 빠르다고 한다. 셰이더를 사용할 수도 있으나, 셰이더가 오히려 처리속
도가 더 느리기 때문에, 셰이더는 블랜딩 같은 효과를 줄때 사용해야 할 것 같다.

RenderTexture, SlideBar같은 컴포넌트들은 툴에서 직접 만들 수 없는 컴포넌트이다. 왜냐하면 이 컴포넌트는
태어나자 마자 다른 컴포넌트와 연결 돼 있어야 하는데 툴에서 직접 만든다면 연결 고리를 연결 해 주어야 하고
그것은 컴포넌트들의 속성을 이해해야 하는 것으로 이어지기 때문에, 특별 컴포넌트들은 태어날때 연결해 주고
연결한 컴포넌트들은 지울 수 없는 속성을 가지게 될 것이다. 리스트 컴포넌트는 다수의 행과 하나의 열이 있을
수 있지만 다수의 행과 2개의 열이 있을수도 또 다양한 열이 있을수도, 배경그림이 같이 스크롤되어지는 리스트
도 있을 수 있다. 그래서 이 부분을 자유롭게 만들까 생각했는데, 자유롭게 만들면 만들수록 컴포넌트의 속성에
알아야 할 것들이 많아지기 때문에 템플릿으로 몇개를 제공해주고 만들고, 특이한 리스트일 경우에는 컴포넌트
를 만들어 써야 할 것 같다.

이미지를 렌더텍스쳐에 찍었을때 그게 잘 찍혔는지 확인하고 싶은데, 단순하게 생각한다면 50, 50에 어떤 색깔이
찍혀있는지를 알면 될 것이다. 하지만 실질적으로 그렇게 하기에는 쉽지 않다. 어떤 툴이나 어떤 프로그램을 쓰면
된다고도 하지만, 쉬운 길은 아니다. 단지 테스트 만으로 그렇게 복잡한 무언가를 써야 한다는 것이 껄끄럽기도
하고 나중에 유지보수에 손이 더 많이 갈 꺼 같기도 하고 그래서 주저하게 된다. 궁극적으로 클라이언트에 TDD를
붙이기 힘든 이유는 이렇게 픽셀 자체를 검사하지 못한다는 것에 있다고 해도 과언이 아니다. 그래서 다른 방법을
생각해 보았다. 마우스가 그 픽셀에 도착했을때 이미지가 바뀌는게 있다면 렌데텍스쳐를 한다음 그 컴포넌트를
올리고 마우스를 그 픽셀에 갖다댄 후 그 컴포넌트가 hovered로 바뀌었다면 잘 되었다고 할 수 있다. 이것을 확장
한다면 만약에 캐릭터가 어떤 스킬을 쓴 후 100pixel 이동하였다면 마우스를 100pixel 이후에 위치하고 캐릭터가
선택되었는지 확인한다면 될 것이다. 

스택멤버변수를 Update나 렌더링 함수에는 사용하는 것으로도 속도가 상당히 빨라진다는 것을 알았다. 전방선언
은 할수 없고, 의존관계는 증가되나, 그것을 커버하고 남을 정도로 업데이트 함수나 렌더링 함수에서 자주 불리는
것들은 스택멤버변수로 만들것이 강력히 권고된다. 그리고 앞으로도 Update와 Render함수에서 자주 불리는 것들을 유심히 관찰하고 스택멤버변수
를 사용하는 것을 적극 고려해야겠다. 물론 다른 것들도 스택에 올리는 것이 좋으니까 크기가 작고 가벼우면 스택에
올리는 쪽으로 작성할 것을 고려해야겠다.

Scroll Bar를 만들때 가로 스크롤 바는 기존에 만들어진 ImageGrid3으로 만들어지는데 세로 스크롤 바는 세로로 
늘리는 기능이 없기 때문에 세로 ImageGrid3가 있어야 한다. 그래서 Rotation을 생각했는데 Rotation을 했을때에
부동소수점 연산이 생기고, 두번째는 텍스쳐 좌표를 맞춰야 한다. 3d에서는 버텍스 각각이 텍스쳐 좌표를 가지고
있어서 rotation 했을때에도 텍스쳐 좌표가 맞춰지지만, 2D에서는 텍스쳐 좌표가 없기 때문에 샘플링 방법에서 
rotation을 적용해야 한다. 즉 연산이 너무 많이 들어간다. UI는 빠른게 생명이고 혹시 rotation 해야 하는 ui가 필요
하면(예를들면 회전하는 미니맵) 그 컴포넌트에 한해서 rotation하게 만들고 자식 노드들은 rotation이 안되게 
될 것이다. rotation이 되게 한다면 컴포지트 패턴 특성상 전부 그 rotation의 영향을 받게 되어서 전체적으로 느려
지게 되기 때문이다. 그래서 가로 세로 컴포넌트를 다 구현해야 한다.