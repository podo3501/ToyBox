UI좌표는 해상도의 변화에 따라서 UI의 위치가 변하게 되는데 그 부분을 방지하기 위해 0-1 까지로 한 다음
현재 해상도에 곱하면 실제 위치 값이 나오게 된다. (800x600, 0.5 0.5라면 400, 300) UI의 시작좌표는 일반적
인 좌상단이 아니라 중점으로 한다.

다이얼로그를 만들던 중 마우스에서 클릭하면 3개의 다른 지점에서 반응 하는게 아니라 버튼 클래스에서
전체적으로 반응하는데 추후에 이 클래스를 가져다가 쓰는 곳에서 이 부분을 또 만들어야 하는 단점이 있기에
리팩토링해서 그 부분을 만든다. 이미지1개짜리 버튼을 만들려면 새로 만들거나 이미지를 3개로 쪼개서 써야 
하기 때문에 각각의 하나 짜리를 만든후 3개로 묶도록 리팩토링 한다.

서비스 로케이터 패턴을 쓸려고 했는데 일단 전역적인 것은 나중에 더 필요하게 되면 고려하기로 했다.

UI에서 Component의 위치는 Component를 가지는 클래스가 정하고 그 위치에 어디가 중심인지는 Component
자신이 알고 있다. Component의 크기는 Component가 가지고 있어서 Picking같은 것을 호출할때에는 Component
에서 처리하도록 한다.

friend함수인 to_json 을 쓸 것인가 아니면 Process 같은 중간 클래스를 만들어서 read, write를 한데 묶어서 할까
했는데 to_json을 쓰면 장점은 복사 생성자나 = 이런 것들을 쓸 수 있게 되어서 가독성이 좋고, 중간 클래스를 
만들면 read, write 한군데에서 처리하니 friend 함수도 사라지고 코드가 깔끔해지는 장점이 있다. 일반적인 가독
성이면 to_json이 좋고, 프로그램적 가독성은 Process로 처리하는게 좋을 것 같다. 이번에는 to_json으로 해서 
복사생성자 같은 것들을 좀 더 사용하도록 해 보겠다. 속도는 to_json이 더 빠를지 느릴지 잘 모르겠지만, 일반적으로
만들어 준것이 만든것보다 좋을 것 같다. 
json에서 get<T>()를 사용하면 읽을때 타입별로 객체를 생성하고 초기화 하는데, 이걸 안쓰면 직접 이 부분을 
만들어야 한다. 예를 들면 "Type": "Button" 이렇게 저장하고 읽을때 버튼 클래스를 읽어야 하는 부분을 구현해야
하는데 만들기 쉽고 어렵고의 문제라기 보다는 코드가 많아지면 결국 관리할때 문제가 생기기 때문이다.
get<T>()를 사용한다고 해도 tag 로처리할지 RTTI로 할지 고민하다 tag로 처리하였다. Process를 사용한다고 해도
복사 생성자 이동생성자는 있어야 하고, 바꾸면 to_json 부분이 process 로 바뀌는 것 말고는 크게 달라질것 같지
않다. 결국 Process클래스는 to_json from_json을 if문 하나로 이쪽저쪽 갈라주는 용도일 뿐이니까.
그렇개 생각해서 Process 클래스를 만들려고 보니 클래스 안에 클래스 처럼 중첩구조를 가진 데이터에서 Process()
함수를 불러줄때 json에 키값을 셋팅하고 넘겨주어야 한다. 결국 to_json을 하나로 합치는 것 이외에 어떤 이점이
찾을 수 없게 된다. friend가 걸리적 거리고 함수가 두개 쌍이 있어야 하지만 그것을 제외하기 위해서 

UI에서 SRT할 일이 별로 없기 때문에 Transform 하는 클래스의 존재가 좀 그렇긴 하지만, 이 클래스를 만드는
이유는 SRT를 생각해서 순서를 정해주어서 곱해야 하기 때문에 매우 귀찮기 때문에 설정한 후에 update 할때
순서에 맞게 처리해 주면 된다. 계속 처리하기 싫을 경우에는 Dirty를 사용해서 바뀌었을때만 하면 되니까. 이 
클래스의 존재 이유는 순서가 헷갈리지 않기 하게 위해서이다. 
AddComponent에서 좌표값은 Translate 이고 ChangeArea는 Scale인데 이 두개가 바뀌어서 호출 되면 이상해
지니까 그것을 한군데로 하기 위함이긴 한데, 실제 이 클래스가 나중에 만들어질지는 모르겠다.
//TransformComponent* transComp = panel->GetTransformComponent("Button");
//transComp->ChangeArea({ 0, 0, 126,48 });

XMVECTOR는 SIMD(빠른 처리)를 위해서 사용. GPU로 값을 옮길때에는 XMFLOAT(단순구조체타입)으로 변환
해서 옮긴다. 즉 cpu에서 처리할때는 빨리 처리해야 하기 때문에. 2D의 경우에는 XMUINT2가 있는데 이건 SIMD
와는 관계가 없다. 그렇기 때문에 2D용 단순 구조체 타입도 없다. 그럼에도 불구하고 이름을 비슷하게 지은 이유는
아마도 XMVECTOR와 XMUINT2가 변환 되는 것을 지원하기 때문인 것 같다. SIMD를 사용하고 싶으면 XMUINT2
를 XMVECTOR로 바꾼후 연산하고 그다음에 되돌리면 된다.

UI 이름을 unique하게 만들지 말지 고민하다가 유니크 하게 만들었을 경우 닫힘 버튼 같은 경우에는 유니크 하지
않은 이름 때문에 코드가 이상하게 될 것 같다. 그래서 일단은 유니크하게 만들고 추후에 시간이 지난후 실제로
데이터를 만들면서 생각해 보기로 하자. 지금 생각해서 만들면 나중에 가서 또 다시 만들어야 할 것 같다.

리스트는 이러한 형식을 담는 것이다라는 것이고, 넣을 컨테이너를 요청하고 리스트에서 받아서 데이터를 셋팅
하는 방식으로. 첫번째 attach한 컴포넌트의 형식으로 만들어서 리턴. 세이브할때에는 형식을 세이브. 리스트 컴
포넌트는 리스트와 사이드바로 이루어져 있고 사이드 바는 컴포넌트이지만 혼자서는 만들어지지 않는 특별 컴
포넌트. 리스트와 사이드 바는 callback으로 리스트컴포넌트에 정보를 보내고 중간에서 리스트 컴포넌트는 서로
의 정보를 전달함. 리스트 안에 데이터를 넣을때에는 id로 찾아서 넣는다. 그런데 여기서 문제는 id가 unique하면
코딩할때 id문제로 힘들 것 같다. unique한게 어느 기점부터 unique 하게 바꿔야 하지 않을까?