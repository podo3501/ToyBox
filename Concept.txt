UI좌표는 해상도의 변화에 따라서 UI의 위치가 변하게 되는데 그 부분을 방지하기 위해 0-1 까지로 한 다음
현재 해상도에 곱하면 실제 위치 값이 나오게 된다. (800x600, 0.5 0.5라면 400, 300) UI의 시작좌표는 일반적
인 좌상단이 아니라 중점으로 한다.

다이얼로그를 만들던 중 마우스에서 클릭하면 3개의 다른 지점에서 반응 하는게 아니라 버튼 클래스에서
전체적으로 반응하는데 추후에 이 클래스를 가져다가 쓰는 곳에서 이 부분을 또 만들어야 하는 단점이 있기에
리팩토링해서 그 부분을 만든다. 이미지1개짜리 버튼을 만들려면 새로 만들거나 이미지를 3개로 쪼개서 써야 
하기 때문에 각각의 하나 짜리를 만든후 3개로 묶도록 리팩토링 한다.

서비스 로케이터 패턴을 쓸려고 했는데 일단 전역적인 것은 나중에 더 필요하게 되면 고려하기로 했다.

UI에서 Component의 위치는 Component를 가지는 클래스가 정하고 그 위치에 어디가 중심인지는 Component
자신이 알고 있다. Component의 크기는 Component가 가지고 있어서 Picking같은 것을 호출할때에는 Component
에서 처리하도록 한다.

friend함수인 to_json 을 쓸 것인가 아니면 Process 같은 중간 클래스를 만들어서 read, write를 한데 묶어서 할까
했는데 to_json을 쓰면 장점은 복사 생성자나 = 이런 것들을 쓸 수 있게 되어서 가독성이 좋고, 중간 클래스를 
만들면 read, write 한군데에서 처리하니 friend 함수도 사라지고 코드가 깔끔해지는 장점이 있다. 일반적인 가독
성이면 to_json이 좋고, 프로그램적 가독성은 Process로 처리하는게 좋을 것 같다. 이번에는 to_json으로 해서 
복사생성자 같은 것들을 좀 더 사용하도록 해 보겠다. 속도는 to_json이 더 빠를지 느릴지 잘 모르겠지만, 일반적으로
만들어 준것이 만든것보다 좋을 것 같다. 
json에서 get<T>()를 사용하면 읽을때 타입별로 객체를 생성하고 초기화 하는데, 이걸 안쓰면 직접 이 부분을 
만들어야 한다. 예를 들면 "Type": "Button" 이렇게 저장하고 읽을때 버튼 클래스를 읽어야 하는 부분을 구현해야
하는데 만들기 쉽고 어렵고의 문제라기 보다는 코드가 많아지면 결국 관리할때 문제가 생기기 때문이다.
get<T>()를 사용한다고 해도 tag 로처리할지 RTTI로 할지 고민하다 tag로 처리하였다. Process를 사용한다고 해도
복사 생성자 이동생성자는 있어야 하고, 바꾸면 to_json 부분이 process 로 바뀌는 것 말고는 크게 달라질것 같지
않다. 결국 Process클래스는 to_json from_json을 if문 하나로 이쪽저쪽 갈라주는 용도일 뿐이니까.
그렇개 생각해서 Process 클래스를 만들려고 보니 클래스 안에 클래스 처럼 중첩구조를 가진 데이터에서 Process()
함수를 불러줄때 json에 키값을 셋팅하고 넘겨주어야 한다. 결국 to_json을 하나로 합치는 것 이외에 어떤 이점이
찾을 수 없게 된다. friend가 걸리적 거리고 함수가 두개 쌍이 있어야 하지만 그것을 제외하기 위해서 

UI에서 SRT할 일이 별로 없기 때문에 Transform 하는 클래스의 존재가 좀 그렇긴 하지만, 이 클래스를 만드는
이유는 SRT를 생각해서 순서를 정해주어서 곱해야 하기 때문에 매우 귀찮기 때문에 설정한 후에 update 할때
순서에 맞게 처리해 주면 된다. 계속 처리하기 싫을 경우에는 Dirty를 사용해서 바뀌었을때만 하면 되니까. 이 
클래스의 존재 이유는 순서가 헷갈리지 않기 하게 위해서이다. 
AddComponent에서 좌표값은 Translate 이고 ChangeArea는 Scale인데 이 두개가 바뀌어서 호출 되면 이상해
지니까 그것을 한군데로 하기 위함이긴 한데, 실제 이 클래스가 나중에 만들어질지는 모르겠다.
//TransformComponent* transComp = panel->GetTransformComponent("Button");
//transComp->ChangeArea({ 0, 0, 126,48 });

XMVECTOR는 SIMD(빠른 처리)를 위해서 사용. GPU로 값을 옮길때에는 XMFLOAT(단순구조체타입)으로 변환
해서 옮긴다. 즉 cpu에서 처리할때는 빨리 처리해야 하기 때문에. 2D의 경우에는 XMUINT2가 있는데 이건 SIMD
와는 관계가 없다. 그렇기 때문에 2D용 단순 구조체 타입도 없다. 그럼에도 불구하고 이름을 비슷하게 지은 이유는
아마도 XMVECTOR와 XMUINT2가 변환 되는 것을 지원하기 때문인 것 같다. SIMD를 사용하고 싶으면 XMUINT2
를 XMVECTOR로 바꾼후 연산하고 그다음에 되돌리면 된다.

UI 이름을 unique하게 만들지 말지 고민하다가 유니크 하게 만들었을 경우 닫힘 버튼 같은 경우에는 유니크 하지
않은 이름 때문에 코드가 이상하게 될 것 같다. 그래서 일단은 유니크하게 만들고 추후에 시간이 지난후 실제로
데이터를 만들면서 생각해 보기로 하자. 지금 생각해서 만들면 나중에 가서 또 다시 만들어야 할 것 같다.

리스트는 이러한 형식을 담는 것이다라는 것이고, 넣을 컨테이너를 요청하고 리스트에서 받아서 데이터를 셋팅
하는 방식으로. 첫번째 attach한 컴포넌트의 형식으로 만들어서 리턴. 세이브할때에는 형식을 세이브. 리스트 컴
포넌트는 리스트와 사이드바로 이루어져 있고 사이드 바는 컴포넌트이지만 혼자서는 만들어지지 않는 특별 컴
포넌트. 리스트와 사이드 바는 callback으로 리스트컴포넌트에 정보를 보내고 중간에서 리스트 컴포넌트는 서로
의 정보를 전달함. 리스트 안에 데이터를 넣을때에는 id로 찾아서 넣는다. 그런데 여기서 문제는 id가 unique하면
코딩할때 id문제로 힘들 것 같다. unique한게 어느 기점부터 unique 하게 바꿔야 하지 않을까?'

스크롤을 내릴때 분명 내려가야 하는데 마우스가 잘못됐거나 하는 이유로 스크롤이 안된 경우에는 내려갈 것을
기대한 눈과 뇌가 조금 '엇'하는 느낌이 온다. 그렇기 때문에 마우스 스크롤로 내릴때에는 다 내려갔음에도 불구
하고 약간 내려갔다가 올라오는 효과가 있어야 눈과 뇌가 편하다.

싱글톤(전역클래스)이 나쁘다고 불려지는건 데이터가 '가변적'인 경우, 여러군데서 데이터를 수정하면 누가 수정
했는지 알기 어렵고, 여기저기서 h를 인클루드 하기 때문에 리팩토링이 안된다는 것인데, 이 두 부분을 적절히
조절하는가가 싱글톤을 잘 쓸수 있는 비결이라고 생각한다. 싱글톤은 안 쓸수는 없다. 안쓰면 너무 많은 함수에
인자로 들어가거나(키보드 클래스), 로그 찍어야 하는데 함수인자로 로그 인자가 들어가면 인상이 찌푸려 질수
밖에 없다. 사운드도 너무 다양하게 여기저기서 쓰이기 때문에 싱글톤이나 그런 비슷한 종류를 안 쓸래야 안 쓸
수가 없다. 따라서 싱글톤을 사용할때에는 데이터가 가변적인가, 최소한의 include로 지역적으로 감출 수 있는가
가 잘 쓰는 방법일 것이다.

컨테이너 컴포넌트의 역할은 마우스가 올라가면 선택된 색깔로 변하고 클릭하면 callback을 날려주고 선택된 
이미지로 바뀌는 역할 평소 제일 연한, 조금 진한, 진한 으로 바뀜. 밑에 배경 색깔이 달라지는 것임. 컨테이너는 
콤보박스, 리스트 등에 쓰임

view는 조회전용으로 쓸때가 베스트임. 무언가를 넣기 위해서 먼저 검사하는 부분에 view를 넣게 되면 다른 코드
에서 insert를 하고 나서 값이 바뀌었음에도 view는 이전 값으로 검사할 수 있음.
template <typename Container>
Texture* findTexture(const Container& textureList, const wstring& filename)
{
    //filename이 갱신되기 전까지는 view는 갱신되지 않기 때문에 nullptr 제외하는 이 코드는 매번 돌지 않는다.
    auto validTextures = textureList | std::ranges::views::filter([](const auto& tex) {
        return tex != nullptr; // nullptr 제외
        });

    auto find  = ranges::find_if(validTextures, [&filename](const auto& tex) {
        return tex->GetFilename() == filename;
        });

    if (find != validTextures.end())
        return (*find).get();

    return nullptr;
}
이 코드에서 filename이 동일한데 textureList가 바뀌었다면, textureList가 바뀐것을 갱신하지 않고 view 처리를 진
행함. 왜냐하면 filename이 동일하기 때문에 view를 갱신할 이유가 없다고 판단하기 때문. 즉, insert 하기 전에 
동일하게 이 로직을 통과한다면 결과가 올바르겠지만, 다른 함수에서 textureList를 넣고 나서 여기서 같은 이름으로
처리하게 된다면 view는 이전 view의 값을 사용하기 때문에 다른 결과가 나온다. 그래서 읽을때  사용하는게
베스트. 그렇지 않다면 사용자가 잘 생각해야 한다. 그리고 view에서 오류가 나면 찾기가 힘들 것 같다.

버튼 컴포넌트 같은 경우에 밖에서 컨테이너 컴포넌트를 넣어주어야 하는데 버튼 컴포넌트는 컨테이너 컴포넌
트가 없으면 버튼의 역할을 하지 못한다. 그 말은 밖에서 컴포넌트를 넣어주는게 아니라 밖에서 인자를 넣어서 
내부적으로 컨테이너 컴포넌트를 생성하는 방법이 맞지 않는가 하는 것인데 코드적으로는 인자를 넣고 내부적
으로 컴포넌트를 생성한다면 인자가 들어갔다가 같은 인자가 다시 컴포넌트에 건네주게 된다. 즉 함수에 많은
인자가 생기는게 불가피해 질 것이다. 그리고 그것들은 단지 다리역할만 할 가능성도 많아진다. 그렇다고 해서
클래스에 컴포넌트에 넣는 식으로만 코딩한다면 책임을 지지 않는다는 인상이 강하게 남는다. 그래서 helper
함수를 만들어서 하는 방식으로 해야 한다. 지금은 헬퍼 함수가 2개가 있는데 그중에 Create 함수가 별일 없이
넘겨주는 역할만 하는 것 같다. 그래서 이 Create 함수와 컨테이너 만드는 함수를 합쳐야 할 것 같다.

렌더 텍스쳐 해서 부분만 보여주는 것은 렌더 텍스쳐 할때 scissor로 잘라내고, trans matrix로 이동해서 부분만
텍스쳐에 그리는 방식을 취하는게 가장 빠르다고 한다. 셰이더를 사용할 수도 있으나, 셰이더가 오히려 처리속
도가 더 느리기 때문에, 셰이더는 블랜딩 같은 효과를 줄때 사용해야 할 것 같다.

RenderTexture, SlideBar같은 컴포넌트들은 툴에서 직접 만들 수 없는 컴포넌트이다. 왜냐하면 이 컴포넌트는
태어나자 마자 다른 컴포넌트와 연결 돼 있어야 하는데 툴에서 직접 만든다면 연결 고리를 연결 해 주어야 하고
그것은 컴포넌트들의 속성을 이해해야 하는 것으로 이어지기 때문에, 특별 컴포넌트들은 태어날때 연결해 주고
연결한 컴포넌트들은 지울 수 없는 속성을 가지게 될 것이다. 리스트 컴포넌트는 다수의 행과 하나의 열이 있을
수 있지만 다수의 행과 2개의 열이 있을수도 또 다양한 열이 있을수도, 배경그림이 같이 스크롤되어지는 리스트
도 있을 수 있다. 그래서 이 부분을 자유롭게 만들까 생각했는데, 자유롭게 만들면 만들수록 컴포넌트의 속성에
알아야 할 것들이 많아지기 때문에 템플릿으로 몇개를 제공해주고 만들고, 특이한 리스트일 경우에는 컴포넌트
를 만들어 써야 할 것 같다.

이미지를 렌더텍스쳐에 찍었을때 그게 잘 찍혔는지 확인하고 싶은데, 단순하게 생각한다면 50, 50에 어떤 색깔이
찍혀있는지를 알면 될 것이다. 하지만 실질적으로 그렇게 하기에는 쉽지 않다. 어떤 툴이나 어떤 프로그램을 쓰면
된다고도 하지만, 쉬운 길은 아니다. 단지 테스트 만으로 그렇게 복잡한 무언가를 써야 한다는 것이 껄끄럽기도
하고 나중에 유지보수에 손이 더 많이 갈 꺼 같기도 하고 그래서 주저하게 된다. 궁극적으로 클라이언트에 TDD를
붙이기 힘든 이유는 이렇게 픽셀 자체를 검사하지 못한다는 것에 있다고 해도 과언이 아니다. 그래서 다른 방법을
생각해 보았다. 마우스가 그 픽셀에 도착했을때 이미지가 바뀌는게 있다면 렌데텍스쳐를 한다음 그 컴포넌트를
올리고 마우스를 그 픽셀에 갖다댄 후 그 컴포넌트가 hovered로 바뀌었다면 잘 되었다고 할 수 있다. 이것을 확장
한다면 만약에 캐릭터가 어떤 스킬을 쓴 후 100pixel 이동하였다면 마우스를 100pixel 이후에 위치하고 캐릭터가
선택되었는지 확인한다면 될 것이다. 

스택멤버변수를 Update나 렌더링 함수에는 사용하는 것으로도 속도가 상당히 빨라진다는 것을 알았다. 전방선언
은 할수 없고, 의존관계는 증가되나, 그것을 커버하고 남을 정도로 업데이트 함수나 렌더링 함수에서 자주 불리는
것들은 스택멤버변수로 만들것이 강력히 권고된다. 그리고 앞으로도 Update와 Render함수에서 자주 불리는 것들을 유심히 관찰하고 스택멤버변수
를 사용하는 것을 적극 고려해야겠다. 물론 다른 것들도 스택에 올리는 것이 좋으니까 크기가 작고 가벼우면 스택에
올리는 쪽으로 작성할 것을 고려해야겠다.

Scroll Bar를 만들때 가로 스크롤 바는 기존에 만들어진 ImageGrid3으로 만들어지는데 세로 스크롤 바는 세로로 
늘리는 기능이 없기 때문에 세로 ImageGrid3가 있어야 한다. 그래서 Rotation을 생각했는데 Rotation을 했을때에
부동소수점 연산이 생기고, 두번째는 텍스쳐 좌표를 맞춰야 한다. 3d에서는 버텍스 각각이 텍스쳐 좌표를 가지고
있어서 rotation 했을때에도 텍스쳐 좌표가 맞춰지지만, 2D에서는 텍스쳐 좌표가 없기 때문에 샘플링 방법에서 
rotation을 적용해야 한다. 즉 연산이 너무 많이 들어간다. UI는 빠른게 생명이고 혹시 rotation 해야 하는 ui가 필요
하면(예를들면 회전하는 미니맵) 그 컴포넌트에 한해서 rotation하게 만들고 자식 노드들은 rotation이 안되게 
될 것이다. rotation이 되게 한다면 컴포지트 패턴 특성상 전부 그 rotation의 영향을 받게 되어서 전체적으로 느려
지게 되기 때문이다. 그래서 가로 세로 컴포넌트를 다 구현해야 한다. 개별적 rotation을 할때에는 draw에서 rotate
항목을 사용하여 rotation시킨다. 좌표를 로테이션 할 필요는 없고 DirectXTK12에서 제공하는 rotation을 사용해서
텍스쳐가 찍힐때 로테이션을 한다. 텍스쳐만 로테이션 하기 때문에 눌러지는 효과가 있을 경우 그 영역부분은 
update에서 rotation 해야할 듯 하다.

이미지의 좌표를 json으로 저장해서 이름으로 불러들이는 시스템이 필요하다. 계속해서 많아지는 좌표들 때문에
점점 코드가 어지럽혀지고 있고, 나중에 이미지를 바꿀때에도 좌표 찍어서 바꿀 수는 없기 때문에. 지금은 툴에서
이미지를 지정하는 부분이 컴포넌트 윈도우에 붙어있는데 그것을 위로 올려서 독립적인 시스템으로 만들 필요성
이 있다. 툴을 켜서 어떤 이미지가 어떤 이름인지 확인하려는데 번거로우면 안되기 때문이다. 

해쉬로 SourceFinder를 만들때 매프레임당 해쉬가 돌지 않도록 로드시에 좌표를 저장해서 Render시에는 해쉬탐색
을 하지 말고 저장된 좌표를 바로 이용하도록 하자. 혹시나 매 프레임당 해쉬가 돌지 않는지 주의해야 할 것이다.
이것저것 설정따라 다르겠지만 대충 700개 이상부터 충돌이 일어난다고 하니, 갯수에도 신경을 쓰자

Composite 패턴과 외부 데이터의 통신은 노드를 다 돌던지, observer 패턴을 쓰던지 싱글톤을 쓰던지 몇가지 밖에
선택 사항이 없다. TextureResourceBinder라는 클래스 하나이기 때문에 전체 노드를 돌면서 필요한 노드에 정보를 
전달하는 방식을 쓸 예정이다. observer 패턴은 로드 세이브 시 불필요한 코드가 많이 들어가고 싱글톤은 안쓰고 
싶다.

TDD를 할때 때때로 인터페이스(함수이름)가 어떻게 나오게 될지 감이 안 잡힐때가 종종 있다. 그럴때에는 TDD를 
작성하려고 해도 작성이 안되고, 대충은 이런 값이 들어가서 저런 값이 나오는건 알겠는데, 정확하지 않을 경우가
종종 있다. 그러면 테스트 코드를 작성하고 실제 코드를 작성하다보면 수시로 인터페이스를 바꿔야 하는 일이 생
기는 경우가 종종 있다. 특히 제일 처음에 클래스를 만들때 이런 경우가 생기는데, 그럴때에는 그냥 TDD 없이 쭉
쭉 하고 나서 TDD를 추가해주는게 나을 수 있다. cpp가 어느정도(50-100줄사이) 가 되면 인터페이스가 잘 변하지
않는 시기가 오니까 이때부터 TDD 코드를 적고, 추후에 테스트할 함수를 만드는게 좋을때가 있다. 굳이 TDD를 먼
저 하려고 인터페이스가 뭐가 나올지 미리 생각할려고 끙끙 댈 이유가 없다는 것이다. 그렇지만 2-300줄이 넘어
가서 TDD를 적용해야지 하면 귀찮아지는 현상이 올 수도 있으니까 어느정도 그림이 나왔다면 그 이후에서는 
Test Driven 해야 할 것이다.

할때 안하고 나중에 해야지 하면 더 크게 고통 받는다. 일에는 순서가 있다. 가장 시급한 것은 하드 코딩을 없애는
것일지도?!

optionalRef를 리턴값으로 쓰는 이유는 큰 struct를 리턴하고자 할때는 복사가 안 이루어지게 하고 싶기 때문에
const&로 내보내려고 하는데 값이 없을 경우 {}를 리턴 해야 하는데 {}를 리턴하려면 지역값이라 &로 내보낼 수가
없기 때문인데, *로 내보내면 되긴 하겠지만, const *는 포인터 값이 안 변하는 것을 뜻하기 때문에 값이 바꾸는
것이 허용된다고 생각할 여지가 있다. 그래서 그 여지를 차단하기 위해서 const &를 리턴값으로 보냄. 거기다가 
optional을 덧붙여서 리턴할때 nullopt를 사용하게 함으로써 큰 struct를 const로 리턴하기에 알맞음.

Assert를 할때 tdd에서는 어디에서 멈춰주었으면  좋겠다라고 해서 assert를 넣는데 툴에서는 이렇게 하면 툴이
멈춰버리는 현상이 발생하겠지. 물론 release로 배포한다면 그런일은 없어지겠지만 debug로 테스트 할때에 계속
걸리기 때문에 번거롭다. 애초에 툴(게임)에서는 assert가 걸리지 않는것이 목적이다. 그렇기 때문에 툴에서 assert
를 건다는 것은 그만큼 큰일날 곳에 assert를 걸어야겠지. 그리고 툴용 assert를 만들려면 전처리기, 즉 TOOL_MODE
라는 것을 만들어야 하는데 이렇게 define을 쓰기 시작하면 지저분해 지는건 시간문제다. define은 되도록이면  
후반부에 유용하게 쓸 수 있도록 개발단계에서는 최대한 자제해야 한다. 이럴 경우에는 리턴값을 받아서 Assert를
걸어서 툴에서는 assert를 안 걸리게끔 해야 할 것이다.

환경	                        assert 목적	                                                assert가 터졌을 때
클라이언트	            잘못된 상태를 개발 초기에 발견	            버그, 즉시 고쳐야 함
테스트 (TDD)	        명시적 검증, 실패 케이스 확인	                테스트 실패로 리포트
툴	                            assert가 걸리면 방해됨	                            개발자 생산성 저하

Assert의 장점은 json같이 그냥 죽어버리는 곳에 assert를 넣는 방법과 tdd에서 리턴값으로 잡기 힘든 내부 로직에서
문제가 생길경우에 유용하게 쓰일 수 있다.

unique_ptr<PatchTexture1> CreatePatchTexture1(const UILayout& layout, const string& bindKey, size_t sourceIndex)
unique_ptr<PatchTexture1> CreateUnboundPatchTexture1(const UILayout& layout)
이렇게 두개의 함수를 만들어야 할까 아니면 하나의 함수에 ""를 넣어서 처리하는게 좋을까 라는 문제에
chatgpt와 대화 결과
현재는 바인딩 유무를 함수로 나누어 명확한 의미를 주는 것이 좋습니다.
클래스 내부 구현은 대부분 공유되므로 굳이 분리할 필요는 없습니다.
이 방식은 나중에 클래스 분리가 필요할 때도 자연스럽게 확장할 수 있는 구조입니다.
인터페이스는 고정된 채 구현만 분리 가능하므로 유지보수와 리팩토링에 유리합니다.
즉, 지금은 함수 분리로 의미를 살리고, 이후 필요시 클래스 분리로 발전시키는 전략이 적절합니다.

SwitchComponent(1)와 ContainerComponent(2)중 어느것이 더 일반적인 UI에 어울리는가.
chatgpt와 대화 결과
일반적인 버튼은 색상, 텍스트 등만 바뀌므로 단일 컴포넌트에서 상태별 속성만 수정하는 방식이 효율적입니다.
특수한 버튼은 상태마다 UI 구성이 크게 달라지므로 상태별 컴포넌트를 따로 구성하는 것이 적합합니다.
방식 1는 성능이 좋고 테스트와 유지보수가 쉽습니다.
방식 2은 디자이너 협업과 시각적 자유도에 유리합니다.
두 방식을 함께 사용하되, 기본은 방식 1, 예외는 방식 2로 설계하면 유연성과 확장성을 모두 챙길 수 있습니다.

PatchTexture1과 PatchTextureLite1은 비슷하게 작동하기 때문에 비슷한 함수를 리팩토링 할려고 여러가지로 구상
했는데, 다이아몬드 상속이 자꾸 되었다. PatchTexture와 PatchTextureLite를 상속받았을때 UIComponent가 둘다
변할 수 있어야 했는데, 그러려면 UIComponent가 PatchTexture와 Lite를 둘다 상속해 줘야 했기 때문이다. 그래서
고심한 결과, CRTP를 사용해서 중복되는 부분을 빼는 것이 가능할지 알아보았다. CRTP를 해도 protected에 접근하
는 것은 안되었기 때문에 friend 키워드를 사용할 수 밖에 없었다. 그렇다면 간단한 composition으로 해보고 안될
때에는 template로 하는 방식을 시용하고 CRTP는  코드  디버깅 및 코드 짜는데 있어서 혼란을 주기 때문에 사용하
지 않기로 했다.

PatchTexture3 부분을 만들때 PatchTexture9, Lite 등등에 통합적으로 사용되는 클래스 impl을 할려고 했을때, protected
함수를 사용할 수 없는 문제가 있었다. 이들은 서로 다르기 때문에 UIComponent를 사용해서 만들었는데 protected
를 사용하려면 UIComponent에 friend를 쓰거나 CRTP를 사용해야 했는데 CRTP를 사용하면 헤더에 정의를 해야하는
단점(헤더들의 의존관계가 폭증함)이 있기 때문에 CRTP가 꺼려진다. CRTP를 쓴다고 해도 friend를 사용해야 한다. 단,
friend class impl<MyClass> 이렇게 되기 때문에 friend가 자기 클래스로 한정된다.

crtp하는 클래스는  헤더에 인클루드를 걸지 않고 그 crtp를 부르는 cpp코드에 인클루드를 하면 되기 때문에 굳이 헤더
파일에 인클루드를 안해도 되는 이점이 존재하지만, 단점은 이 클래스에서 필요한 파일이 뭔지는 모르게 된다. 그리고
개발하는 사람이 사용하는 cpp쪽에서 인클루드를 해줘야 하지만, crtp클래스에서 인클루드 할 것은 뻔한 이치이기 
때문에 주석으로 잘 써놔야 한다.

이번에는 PatchTextureBase클래스를 만들어(원래도 만들어야한다) 그 베이스 클래스에 friend 를 사용해서 protected
함수를  사용하는 방식을 사용했다. UIComponent에서 friend를 사용할 수는 없고, base클래스에서 friend로 impl을 
한다고 한다면  impl이 구현부라는 것을 인지하기 때문에 friend가 용납 가능할 수 있다. 물론 friend 클래스를 잘못 이용할
여지가 있기 때문에 둘중에 하나를 고르라고 한다면 이번처럼 간단한 경우에는 friend로 하고 더 복잡하고 좀 더 유연
하게 처리 하려면 crtp(이건 변환이 특정 클래스까지 변환되기 때문에 특정 클래스의 함수까지도 사용할 수 있다)를  사용
하는 게 맞다고  생각한다.

람다안에 람다안에 람다... 이런식으로 계속해서 들어가는 구조에서 버그가 생기면 어디에서 false를 리턴했는지 찾는
것이 여간 귀찮은 일이 아닐 수 없다. false가 일어났기 때문에 분명 예전에 이것에 대해서 버그라고 규정지은 것이긴 
한데 그 부분을 찾는게 for의 연속이면 그나마 낫겠지만 람다 연속이면 좀 짜증난다. for도 마찬가지겠지만 이렇게 
찾는게 짜증나는 부분은 자주 false를 반환 하는 부분에 있어서 Assert를 걸어주는게 도움이 된다. 

auto FitToTextureSourceCommand::GetTargetType()
{
	switch (m_commandID) {
	case UICommandID::FitToTextureSource: return static_cast<PatchTexture*>(GetTarget());
	case UICommandID::FitToTextureSourceTS: return static_cast<TextureSwitcher*>(GetTarget());
	default: return nullptr;
	}
}

template<typename FuncT>
bool FitToTextureSourceCommand::WithTarget(FuncT&& Func)
{
	switch (m_commandID) {
	case UICommandID::FitToTextureSource: return Func(static_cast<PatchTexture*>(GetTarget()));
	case UICommandID::FitToTextureSourceTS: return Func(static_cast<TextureSwitcher*>(GetTarget()));
	default: return false;
	}
}

예를들어 첫번째 함수처럼 관계가 없는 클래스 간에 다른 타입을 리턴하고 싶을 경우가 있는데 1번 함수처럼
했을 경우는 타입 불일치로 컴파일 에러가 발생한다. 두번째는 타입을 바꿔서 함수 포인터로 넣어주는데
이때 타입을 바꾸고 람다로 이 함수를 받을때 auto로 정의하면 바뀐 타입이 auto에 형변환 되어서 넘어온다.

template <typename T>
decltype(auto) FitToTextureSourceCommand::GetTargetAs()
{
	switch (m_commandID) {
	case UICommandID::FitToTextureSource:		return static_cast<PatchTexture*>(GetTarget());
	case UICommandID::FitToTextureSourceTS:		return static_cast<TextureSwitcher*>(GetTarget());
	}
}

이렇게 바꾸면 되지 않느냐 하지만 auto* switcher = cmd.GetTargetAs<TextureSwitcher*>(); 이런식으로 사용
할때 타입을 넘겨주어야 한다. 왜냐하면 auto는 컴파일 타임에 알아야 하기 때문이다. 만약 이 타입을 알 수 없는
경우는 이 함수를 사용하지 못한다. 반면 

	return WithTarget([this](auto* target) {
		m_size = target->GetSize();
		return target->FitToTextureSource();
		});

함수인자로 넘긴것은 받을때 auto로 받으면서도 알아서 형변환된 값이 들어오기 때문에 사용할때 정확한 타입
을 모르더라도 사용이 가능하게 된다. 즉 템플릿을 사용하면서도 다형성이 가능하게끔 코딩하는 스타일로 템플
릿은 컴파일 타임에 알아야 하는 것인데 이건 런타임에 알 수 있게 하면서 두 타입이 전혀 관계 없을때 다형성을
사용할 수 있는 방법이다. variant와의 차이점은 variant는 완전히 별개인 타입에 적용하는 것이고, 이것은 base
는 같은데 파생된 두 클래스가 우연히 같은 인터페이스 형식을 공유할때 사용할 수 있는 방법이다. 서로다른 
트리를 탔지만 우연찮게 같은 행동을 하는 경우에 사용하면 좋다. 

Component의 조합인 Component는 자신의 크기를 가지고 조합되는 자식들은 크기를 가지지 않는다. setup 시에
부모의 크기로부터 크기를 조절하면 되기 때문에 Component는 크기를 가지는 것과 가지지 않는 것 2개를 구현해
야 한다.

BFS로 렌더링 하는데 가끔씩 DFS로 렌더링 해야 할 때가 있다. ScrollBar가 그런 경우인데 바탕그림과 버튼이 BFS
로 했을때에는 렌더링 순서가 꼬이는 경우가 발생했다. 특히 다른 컴포넌트가 위에 올라올 경우가 그랬는데, BFS
와 DFS의 렌더링을 교차로 해 주어야 할 필요성을 느꼈는데, 그래서 컴포넌트가 렌더링 방법을 정하고 만약 값이
없다면 부모의 값으로 적용되어야 겠다. 그래서 기본은 BFS에 옵션으로 DepthRender를 주어서 DepthRender일
때에는 그 밑에 자식들이 BFS로 되기 전까지는 DFS로 적용되어야 한다.

TMP에서 traits 패턴은 template 프로그램의 어려움을 많이 낮추어 줌과 동시에 고질적인 헤더에서 정의 내리는
문제를 해결해 준다. 헤더에서 정의를 하면 include를 해 줘야 하고 그러면 include 폭탄이 되어서 TMP 프로그램
이 점점 어렵게 느껴질 수 밖에 없다. include를 해 줘야 하는 함수들 때문에 헤더에만 사용 가능한 utility를 빼야
하는 작업을 하고 있으면 이게 무의미한 작업 처럼 느껴지는 경우가 많기 때문이다. 그런데 template의 장점을
가져가면서 cpp에 정의내릴 수 있게 된다면 헤더의 압박으로부터 벗어날 수 있고, 코드가 한 파일에 급격히 증가
하는 것을 막을 수 있다. 그리고 잘게 쪼갤 수 있게 되어서 유지보수에 이점이 생긴다. 결국 template는 traits를
쓰지 않으면 유지보수가 어렵기 때문에 traits패턴은 거의 필수이지 않을까 생각한다. 그리고 template를 쓰는 가
장 큰 이유는 런타임에 할 일을 컴파일 타임에 올려서 컴파일 시간을 많이 쓰면서 런타임 시간을 최소한으로 쓰고
자 하는, 즉 최적화와 관련돼 있기 때문에 최적화를 해야 하는 시점에서는 traits패턴은 종종 등장하는 패턴이 되
지 않을까 생각한다. 왜 이게 가능하냐면 traits 패턴은 template<>를 사용하는데 이렇게 사용하면 템플릿이지만
템플릿 특수화, 즉 이 타입에 한해서 사용하겠다 라고 하기 때문에 cpp에 정의 내릴 수 있게 되는 것이기 때문이다.
한 타입만으로 분기 시키기 때문에 concept에서 타입을 여기저기로 나누어 주는 역할을 템플릿 특수화가 대신하기
때문에 concept도 필요한 부분만 사용할 수 있게 만들 수 있고, concept 자체를 헤더 제일 위가 아닌 traits 안으로
집어 넣을 수 있어 헤더를 보다 편하게 볼 수 있도록 도와준다.
TMP가 좋지만 단점.
1. 에러가 복잡하다.
2. concept 난무
3. 헤더에 정의를 해야 한다.
4. 의존관계가 늘어난다.
5. 디버깅시 따라가기가 어렵다.
Traits패턴을 썼을때 기대되는 것은 위의 단점들에 대해서 많은 부분 완화 해 준다는 것이다.

브레이크 그룹과 TDD는 상성이 좋은 것 같다. TDD는 개별 테스트 할 경우가 많은데 다른 테스트에서 찍어놓은 브레
이크 포인터가 방해가 될 때가 종종 있다. 그럴때에는 브레이크 그룹으로 관리해서 그 브레이크 그룹을 해제 하는
방식을 사용한다던가 하면 좋은 해법이 될 것 같다.

UIModule 안에 ResourceBinder가 들어가서 Attach를 다 한다음에 Binder 함수를 콜하면 바인드 되는 형식으로 하고
UIModule을 만들때 Binder 파일명을 인자로 넣는다. UI모듈은 실제 씬에 붙일때 씬모듈이 따로 있고 그 씬 모듈에 
Attach 하는 방식으로 할 예정이다. 모듈은 Attach로 조합 가능하며 예를들면 메신저 모듈은 씬을 옮길때 삭제 되는게
아니라 다른 모듈에 옮겨 붙는 구조로 갈 예정이다. 예외같이 모달 같은 경우는 모든 씬에 쓰이는데 이것도 메모리에서
내리지 않는 방식으로 할 예정. 씬은 로비 게임 등등 따로 존재하나, 내부적으로는 하나의 메인 모듈씬에 뗏다 붙였다 
하면서 하나의 씬에서 처리하는 방식을 사용, 내렸다 올렸다 하지 않고, 서버에서 재요청 하거나 씬이 달라졌다고 해서
UI를 다시 셋팅하기 위해서 씬마다 데이터 클래스를 만드는 것이 없도록 할 예정임. 모듈이 메인 모듈에서 떨어지면 
메모리를 해제할 예정. 자주 쓰이는 UI 모듈은 추후에 다시 생각할 예정. 

UIModule을 만들고 툴에 붙일려고 하는데 RenderTexture가 UIComponent만 취급하기 때문에 UIModule은 UIComponent
가 아니기 때문에 문제가 발생한다. UIModule은 다른 Module과 조립이 가능해야 한다. 예를 들면 메신저 UI는 모든 씬
에서 동일하게 등장하기 때문에 모든 씬에서 메신저 UI를 만드는게 아니라 한번만 만들고 UIModule로 조립해서 씬에서
사용하게 될 것이기 때문이다. 그래서 문제의 해결책은 UIModule을 UIComponent로 변환시키는 Adapter 패턴을
써서 UIComponent로 변환시킨뒤 RenderTexture에서 사용할 수 있도록 만드는 것이다. 결국 Composite 패턴은 커지면
다른 클래스를 물고 있는 클래스로 확장될 수 밖에 없고, 이 클래스는 결국 UIComponent로 만들어져야 작업이 편해
지기 때문이다. UIModule용 Merge같은 것을 만들어서 내부 클래스들을 Merge 할 수도 있지만, 프로그램이 점점 복잡
해지고 오류도 많이 생길 것 같다. 그리고 UIModule이 Adapter를 써서 UIComponent로 바뀌면 Merge같은 것을 쓰지
않고도 attach와 detach가 가능해지기 때문이다. 결론적으로 Composite 패턴은 Adapter 패턴을 같이 가지고 갈 수 밖에 
없는 구조인 것이다.

그냥 UIModuleComponent를 만들면 되지 않느냐 라고 반문할지 모르겠다. Adapter 패턴을 써서 한번 감쌀 필요 없이
그냥 컴포넌트를 만들어서 거기에서 처리하면 되지 않냐라고 할 수 있는데 여기에 문제가 있다. 문제는 이렇게 되었을
경우에는 children이 존재하게 된다. children을 존재하지 않게 만든다고 한다면, 그건 Component의 기능을 안쓴다고
이야기 하는 것과 같다. 이 클래스는 Component도 아니고 애매하게 복잡하게 된다. 그래서 차라리 하나의 컴포넌트를
만들어서 adapter 역할을 시키고 클래스로 빼내는 것이, 아니 UIModuleComponent를 만들어서 처리한다고 해도 결국
UIModule이 클래스로 빠질 것이다. 결국 둘다 같은 말이기 때문에, 책임분리를 위해서 UIModule을 만들고 has로 가지
는 UIModuleAsComponent가 될 것이다. 
 그렇지 않고 children을 가지게끔 설계한다고 하면, render나 update 코드안에 if(UIModule) 이런 코드들이 나올것이
 고 그것은 Composite 패턴에서 재귀호출 프로그램 지옥을 경험하게 될 것이다. 그래서 최대한 if 코드를 안 나오게 만
 드는 것이 Composite 패턴을 잘 활용하는 것이며, adapter 패턴을 써서 구현해서 children을 짤라줘야 if문이 안나오게
 처리할 수 있게 된다.

 static 멤버함수는 멤버함수의 성격보다 일반 함수의 성격을 더 가진다. 일반함수로 만들지 않고 static 멤버함수로 만드
 는 이유는 그 클래스의 public 함수를 일반함수가 호출하니까 static 멤버함수로 만들면 private로 만들 수 있기 때문이다
 프로그램은 public을 최대한 적게 만드는 것이 매우 중요하다.
 일반함수 --> static 멤버함수로 변환 --> 이 함수가 내부적으로 호출하는 함수를 public에서 private으로 이동할 수 있음

 TDD와 테스트는 엄연히 다르다. ThirdParty가 잘 되는지 확인할려고 하는것은 테스트이다. TDD는 설계하기 위해서
 하는 것이기 때문에 이미 설계가 나와 있거나, 간단한 프로그램은 TDD가 맞지 않는다. 인터넷에 TDD를 찾아보면 
 테스트와 TDD를 혼동해서 설명해 놓은 글들이 많다. TDD는 mock을 안하고는 하기가 너무 힘들며, 빠르지 않으면 
 TDD라고 말하기는 힘들것 같다. 테스트 할때마다 무거운 엔진이나 무언가가 돌아간다면, mock 해서 처리 해야 한다.
 그렇지 않으면 결과를 빨리 확인하고 빨리 리팩토링 하는 장점이 다 사라지기 때문이고, 시간을 주면 줄 수록 머릿속
 에서 자꾸 설계를 해 버리기 때문이다. TDD를 하면 설계하지 않는 버릇을 들여야 한다. 오로지 결과와 리팩토링으로
 점진적인 설계를 만들어가야 한다. 머릿속에서 순간적으로 설계를 하다보면 억지로 그 설계로 맞추려고 하기 때문에
 TDD에 방해가 된다. 그리고 이미 되어 있는 코드에 TDD를 접목시킨다고 하면 TDD를 하지 말아야 하는 클래스에 
 테스트를 붙이는 경우가 발생한다. 테스트를 붙이지 말아야 하는 클래스와 테스트를 하는 클래스, 즉 인터페이스 클래스
 는 테스트를 붙이고 구현클래스는 테스트를 붙이지 말아야 한다. 구현클래스가 압도적으로 많기 때문에 테스트는 많아야
 코드의 20% 수준 정도가 된다. 만줄이면 길어야 2천줄 정도가 되지 않을까 한다. 이 프로젝트에는 2개의 구글 테스트
 프로젝트가 있는데 하나는 TDD이고 하나는 그냥 테스트용도이다. 테스트용도는 빈 프로젝트도 되고, Imgui를 붙여서
 뷰어 형식으로 만들수도 있겠다. 그런데 구글 테스트가 기능상 좋은 기능을 제공하기 때문에 사용할 뿐이다.

 씬은 unique_ptr로 가고 transition에서 new로 만들어서 전환 한다음에 씬은 종료를 정확하게 하게 한 다음 
 리소스는 내부적으로 관리하고 나머지 콜백이나 서버 문제는 우아한 종료를 한다. 이유는 렉이 무엇보다 싫기 때문에
 렉을 없애기 위해서는 메모리의 소멸 시점이 정확해야 하며, 그래서 shared_ptr을 안쓰는 이유이다. shared_ptr을 쓰면
 메모리 해제 시점을 알수 없기 때문에 게임에서 렉이 발생하면 잡기가 너무 힘들 뿐더러 애초에 이런 일이 발생하지  않게
 shared_ptr을 아주 보수적으로 접근할 필요가 있다고 생각함. 씬에서 사용되는 리소스는 씬을 통해서 로드하며, 그래야
 씬이 전환될때 씬이 사라지면서 자동적으로 소멸자를 호출해서 지워줄 수 있기 때문이다. 

 버튼 클릭 방법은 클릭후 영역을 벗어났다가 다시 같은 버튼으로 돌아와서 떼면 클릭됐다고 하는 방식을 사용
 한다. 윈도우 형식은 아니고 다른 게임에서 주로 하는 방식인데 hover는 그냥 무조건 반응하고, 나머지는 캡쳐된
 컴포넌트를 반응하는 식인데, 영역을 벗어나도 캡쳐는 유지되지만 이미지는 눌린 이미지에서 노멀로 바뀌고 다시 그
 버튼으로 이동하면 hover 이미지가 아니라 눌린 이미지로 되는 것이다.

 현재 TDD코드는 양이 많은데 내 생각에는 만줄 코드의 tdd코드는 천줄 정도가 나오지 않을까 한다. 구현하다보면 
 다양한 상황에서 테스트 해서 하는 경우가 있는데, 그러면 테스트가 중복이 되어서 여러번 수정을 요구한다. 그래서
 실패하는 테스트를 짠다거나 조합해서 테스트를 한다거나 하는 테스트는 TDD로 하면 안된다. TDD가 아니라 일반적인
 테스트라면 가능하지만, TDD는 실패 성공이 중요한게 아니라 설계를 할수 있는가가 중요하기 때문에, 버그가 생기면
 브레이크 포인터로 잡는 것이지 TDD로 모든 실패상황에 대해서 테스트환경을 만드는건 생산성에 좋지 않다. 물론
 그렇게 하면 작성할때 편하긴 한데, 테스트 환경 구축하는데 시간이 많이 걸릴 뿐 아니라, 새로운 설계에는 하나의 테스
 트면 충분하기 때문에 굳이 실패상황 같은 테스트를 넣어서 테스트를 많이 만들 필요는 없을 것 같다. 이게 테스트와
 TDD의 차이인 것 같다. 